// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package stellar.sdk.xdr

import stellar.sdk.xdr._

// === xdr source ============================================================

//  struct AccountEntry
//  {
//      AccountID accountID;      // master public key for this account
//      int64 balance;            // in stroops
//      SequenceNumber seqNum;    // last sequence number used for this account
//      uint32 numSubEntries;     // number of sub-entries this account has
//                                // drives the reserve
//      AccountID* inflationDest; // Account to vote for during inflation
//      uint32 flags;             // see AccountFlags
//  
//      string32 homeDomain; // can be used for reverse federation and memo lookup
//  
//      // fields used for signatures
//      // thresholds stores unsigned bytes: [weight of master|low|medium|high]
//      Thresholds thresholds;
//  
//      Signer signers<20>; // possible signers for this account
//  
//      // reserved for future use
//      union switch (int v)
//      {
//      case 0:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================

case class AccountEntry (
  accountID: AccountID, 
  balance: Int64, 
  seqNum: SequenceNumber, 
  numSubEntries: Uint32, 
  inflationDest: Option[AccountID], 
  flags: Uint32, 
  homeDomain: String32, 
  thresholds: Thresholds, 
  signers: Array[Signer], 
  ext: AccountEntry.Ext
) {
  def encode(stream: XdrDataOutputStream): Unit = {
    accountID.encode(stream)
    balance.encode(stream)
    seqNum.encode(stream)
    numSubEntries.encode(stream)
    inflationDest match {
      case Some(x) => 
        stream.writeInt(1)
        x.encode(stream)
      case None => stream.writeInt(0)
    }
    flags.encode(stream)
    homeDomain.encode(stream)
    thresholds.encode(stream)
    stream.writeInt(signers.length)
    signers.foreach { _.encode(stream) }
    ext.encode(stream)
  }
}

object AccountEntry {
  def decode(stream: XdrDataInputStream): AccountEntry = AccountEntry(
    AccountID.decode(stream),
    Int64.decode(stream),
    SequenceNumber.decode(stream),
    Uint32.decode(stream),
    if (stream.readInt == 0) None else Some(AccountID.decode(stream)),
    Uint32.decode(stream),
    String32.decode(stream),
    Thresholds.decode(stream),
    (0 until stream.readInt).map(_ => Signer.decode(stream)).toArray,
    Ext.decode(stream)
  )

  sealed trait Ext {
    def encode(stream: XdrDataOutputStream): Unit
  }

  object Ext {
    def decode(stream: XdrDataInputStream): Ext = stream.readInt match {
      case 0 => R_0
      case d => throw new IllegalArgumentException(s"Int value $d is invalid")
    }

    case object R_0 extends Ext {
      def encode(stream: XdrDataOutputStream): Unit = {
        stream.writeInt(0)
      }
    }
  }
}
