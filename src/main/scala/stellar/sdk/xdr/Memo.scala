// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package stellar.sdk.xdr

import stellar.sdk.xdr._

// === xdr source ============================================================

//  union Memo switch (MemoType type)
//  {
//  case MEMO_NONE:
//      void;
//  case MEMO_TEXT:
//      string text<28>;
//  case MEMO_ID:
//      uint64 id;
//  case MEMO_HASH:
//      Hash hash; // the hash of what to pull from the content server
//  case MEMO_RETURN:
//      Hash retHash; // the hash of the tx you are rejecting
//  };

//  ===========================================================================

sealed trait Memo {
  def encode(stream: XdrDataOutputStream): Unit
}

object Memo {
  def decode(stream: XdrDataInputStream): Memo = MemoType.decode(stream) match {
    case MemoType.MEMO_NONE => MEMO_NONE
    case MemoType.MEMO_TEXT => MEMO_TEXT(stream.readString)
    case MemoType.MEMO_ID => MEMO_ID(Uint64.decode(stream))
    case MemoType.MEMO_HASH => MEMO_HASH(Hash.decode(stream))
    case MemoType.MEMO_RETURN => MEMO_RETURN(Hash.decode(stream))
    case d => throw new IllegalArgumentException(s"MemoType value $d is invalid")
  }

  case object MEMO_NONE extends Memo {
    def encode(stream: XdrDataOutputStream): Unit = {
      MemoType.MEMO_NONE.encode(stream)
    }
  }
  case class MEMO_TEXT(x: String) extends Memo {
    def encode(stream: XdrDataOutputStream): Unit = {
      MemoType.MEMO_TEXT.encode(stream)
      stream.writeString(x)
    }
  }
  case class MEMO_ID(x: Uint64) extends Memo {
    def encode(stream: XdrDataOutputStream): Unit = {
      MemoType.MEMO_ID.encode(stream)
      x.encode(stream)
    }
  }
  case class MEMO_HASH(x: Hash) extends Memo {
    def encode(stream: XdrDataOutputStream): Unit = {
      MemoType.MEMO_HASH.encode(stream)
      x.encode(stream)
    }
  }
  case class MEMO_RETURN(x: Hash) extends Memo {
    def encode(stream: XdrDataOutputStream): Unit = {
      MemoType.MEMO_RETURN.encode(stream)
      x.encode(stream)
    }
  }
}
