// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package stellar.sdk.xdr

import stellar.sdk.xdr._

// === xdr source ============================================================

//  union LedgerKey switch (LedgerEntryType type)
//  {
//  case ACCOUNT:
//      struct
//      {
//          AccountID accountID;
//      } account;
//  
//  case TRUSTLINE:
//      struct
//      {
//          AccountID accountID;
//          Asset asset;
//      } trustLine;
//  
//  case OFFER:
//      struct
//      {
//          AccountID sellerID;
//          uint64 offerID;
//      } offer;
//  
//  case DATA:
//      struct
//      {
//          AccountID accountID;
//          string64 dataName;
//      } data;
//  };

//  ===========================================================================

sealed trait LedgerKey {
  def encode(stream: XdrDataOutputStream): Unit
}

object LedgerKey {
  def decode(stream: XdrDataInputStream): LedgerKey = LedgerEntryType.decode(stream) match {
    case LedgerEntryType.ACCOUNT => ACCOUNT(Account.decode(stream))
    case LedgerEntryType.TRUSTLINE => TRUSTLINE(TrustLine.decode(stream))
    case LedgerEntryType.OFFER => OFFER(Offer.decode(stream))
    case LedgerEntryType.DATA => DATA(Data.decode(stream))
    case d => throw new IllegalArgumentException(s"LedgerEntryType value $d is invalid")
  }

  case class ACCOUNT(x: Account) extends LedgerKey {
    def encode(stream: XdrDataOutputStream): Unit = {
      LedgerEntryType.ACCOUNT.encode(stream)
      x.encode(stream)
    }
  }
  case class TRUSTLINE(x: TrustLine) extends LedgerKey {
    def encode(stream: XdrDataOutputStream): Unit = {
      LedgerEntryType.TRUSTLINE.encode(stream)
      x.encode(stream)
    }
  }
  case class OFFER(x: Offer) extends LedgerKey {
    def encode(stream: XdrDataOutputStream): Unit = {
      LedgerEntryType.OFFER.encode(stream)
      x.encode(stream)
    }
  }
  case class DATA(x: Data) extends LedgerKey {
    def encode(stream: XdrDataOutputStream): Unit = {
      LedgerEntryType.DATA.encode(stream)
      x.encode(stream)
    }
  }

  case class Account (
    accountID: AccountID
  ) {
    def encode(stream: XdrDataOutputStream): Unit = {
      accountID.encode(stream)
    }
  }

  object Account {
    def decode(stream: XdrDataInputStream): Account = Account(
      AccountID.decode(stream)
    )
  }
  case class TrustLine (
    accountID: AccountID, 
    asset: Asset
  ) {
    def encode(stream: XdrDataOutputStream): Unit = {
      accountID.encode(stream)
      asset.encode(stream)
    }
  }

  object TrustLine {
    def decode(stream: XdrDataInputStream): TrustLine = TrustLine(
      AccountID.decode(stream),
      Asset.decode(stream)
    )
  }
  case class Offer (
    sellerID: AccountID, 
    offerID: Uint64
  ) {
    def encode(stream: XdrDataOutputStream): Unit = {
      sellerID.encode(stream)
      offerID.encode(stream)
    }
  }

  object Offer {
    def decode(stream: XdrDataInputStream): Offer = Offer(
      AccountID.decode(stream),
      Uint64.decode(stream)
    )
  }
  case class Data (
    accountID: AccountID, 
    dataName: String64
  ) {
    def encode(stream: XdrDataOutputStream): Unit = {
      accountID.encode(stream)
      dataName.encode(stream)
    }
  }

  object Data {
    def decode(stream: XdrDataInputStream): Data = Data(
      AccountID.decode(stream),
      String64.decode(stream)
    )
  }
}
