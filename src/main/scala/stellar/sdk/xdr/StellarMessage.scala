// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package stellar.sdk.xdr

import stellar.sdk.xdr._

// === xdr source ============================================================

//  union StellarMessage switch (MessageType type)
//  {
//  case ERROR_MSG:
//      Error error;
//  case HELLO:
//      Hello hello;
//  case AUTH:
//      Auth auth;
//  case DONT_HAVE:
//      DontHave dontHave;
//  case GET_PEERS:
//      void;
//  case PEERS:
//      PeerAddress peers<100>;
//  
//  case GET_TX_SET:
//      uint256 txSetHash;
//  case TX_SET:
//      TransactionSet txSet;
//  
//  case TRANSACTION:
//      TransactionEnvelope transaction;
//  
//  // SCP
//  case GET_SCP_QUORUMSET:
//      uint256 qSetHash;
//  case SCP_QUORUMSET:
//      SCPQuorumSet qSet;
//  case SCP_MESSAGE:
//      SCPEnvelope envelope;
//  case GET_SCP_STATE:
//      uint32 getSCPLedgerSeq; // ledger seq requested ; if 0, requests the latest
//  };

//  ===========================================================================

sealed trait StellarMessage {
  def encode(stream: XdrDataOutputStream): Unit
}

object StellarMessage {
  def decode(stream: XdrDataInputStream): StellarMessage = MessageType.decode(stream) match {
    case MessageType.ERROR_MSG => ERROR_MSG(Error.decode(stream))
    case MessageType.HELLO => HELLO(Hello.decode(stream))
    case MessageType.AUTH => AUTH(Auth.decode(stream))
    case MessageType.DONT_HAVE => DONT_HAVE(DontHave.decode(stream))
    case MessageType.GET_PEERS => GET_PEERS
    case MessageType.PEERS => PEERS((0 until stream.readInt).map(_ => PeerAddress.decode(stream)).toArray)
    case MessageType.GET_TX_SET => GET_TX_SET(Uint256.decode(stream))
    case MessageType.TX_SET => TX_SET(TransactionSet.decode(stream))
    case MessageType.TRANSACTION => TRANSACTION(TransactionEnvelope.decode(stream))
    case MessageType.GET_SCP_QUORUMSET => GET_SCP_QUORUMSET(Uint256.decode(stream))
    case MessageType.SCP_QUORUMSET => SCP_QUORUMSET(SCPQuorumSet.decode(stream))
    case MessageType.SCP_MESSAGE => SCP_MESSAGE(SCPEnvelope.decode(stream))
    case MessageType.GET_SCP_STATE => GET_SCP_STATE(Uint32.decode(stream))
    case d => throw new IllegalArgumentException(s"MessageType value $d is invalid")
  }

  case class ERROR_MSG(x: Error) extends StellarMessage {
    def encode(stream: XdrDataOutputStream): Unit = {
      MessageType.ERROR_MSG.encode(stream)
      x.encode(stream)
    }
  }
  case class HELLO(x: Hello) extends StellarMessage {
    def encode(stream: XdrDataOutputStream): Unit = {
      MessageType.HELLO.encode(stream)
      x.encode(stream)
    }
  }
  case class AUTH(x: Auth) extends StellarMessage {
    def encode(stream: XdrDataOutputStream): Unit = {
      MessageType.AUTH.encode(stream)
      x.encode(stream)
    }
  }
  case class DONT_HAVE(x: DontHave) extends StellarMessage {
    def encode(stream: XdrDataOutputStream): Unit = {
      MessageType.DONT_HAVE.encode(stream)
      x.encode(stream)
    }
  }
  case object GET_PEERS extends StellarMessage {
    def encode(stream: XdrDataOutputStream): Unit = {
      MessageType.GET_PEERS.encode(stream)
    }
  }
  case class PEERS(x: Array[PeerAddress]) extends StellarMessage {
    def encode(stream: XdrDataOutputStream): Unit = {
      MessageType.PEERS.encode(stream)
      stream.writeInt(x.length)
      x.foreach { _.encode(stream) }
    }
  }
  case class GET_TX_SET(x: Uint256) extends StellarMessage {
    def encode(stream: XdrDataOutputStream): Unit = {
      MessageType.GET_TX_SET.encode(stream)
      x.encode(stream)
    }
  }
  case class TX_SET(x: TransactionSet) extends StellarMessage {
    def encode(stream: XdrDataOutputStream): Unit = {
      MessageType.TX_SET.encode(stream)
      x.encode(stream)
    }
  }
  case class TRANSACTION(x: TransactionEnvelope) extends StellarMessage {
    def encode(stream: XdrDataOutputStream): Unit = {
      MessageType.TRANSACTION.encode(stream)
      x.encode(stream)
    }
  }
  case class GET_SCP_QUORUMSET(x: Uint256) extends StellarMessage {
    def encode(stream: XdrDataOutputStream): Unit = {
      MessageType.GET_SCP_QUORUMSET.encode(stream)
      x.encode(stream)
    }
  }
  case class SCP_QUORUMSET(x: SCPQuorumSet) extends StellarMessage {
    def encode(stream: XdrDataOutputStream): Unit = {
      MessageType.SCP_QUORUMSET.encode(stream)
      x.encode(stream)
    }
  }
  case class SCP_MESSAGE(x: SCPEnvelope) extends StellarMessage {
    def encode(stream: XdrDataOutputStream): Unit = {
      MessageType.SCP_MESSAGE.encode(stream)
      x.encode(stream)
    }
  }
  case class GET_SCP_STATE(x: Uint32) extends StellarMessage {
    def encode(stream: XdrDataOutputStream): Unit = {
      MessageType.GET_SCP_STATE.encode(stream)
      x.encode(stream)
    }
  }
}
