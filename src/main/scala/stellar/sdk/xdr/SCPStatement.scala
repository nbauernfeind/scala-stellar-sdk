// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package stellar.sdk.xdr

import stellar.sdk.xdr._

// === xdr source ============================================================

//  struct SCPStatement
//  {
//      NodeID nodeID;    // v
//      uint64 slotIndex; // i
//  
//      union switch (SCPStatementType type)
//      {
//      case SCP_ST_PREPARE:
//          struct
//          {
//              Hash quorumSetHash;       // D
//              SCPBallot ballot;         // b
//              SCPBallot* prepared;      // p
//              SCPBallot* preparedPrime; // p'
//              uint32 nC;                // c.n
//              uint32 nH;                // h.n
//          } prepare;
//      case SCP_ST_CONFIRM:
//          struct
//          {
//              SCPBallot ballot;   // b
//              uint32 nPrepared;   // p.n
//              uint32 nCommit;     // c.n
//              uint32 nH;          // h.n
//              Hash quorumSetHash; // D
//          } confirm;
//      case SCP_ST_EXTERNALIZE:
//          struct
//          {
//              SCPBallot commit;         // c
//              uint32 nH;                // h.n
//              Hash commitQuorumSetHash; // D used before EXTERNALIZE
//          } externalize;
//      case SCP_ST_NOMINATE:
//          SCPNomination nominate;
//      }
//      pledges;
//  };

//  ===========================================================================

case class SCPStatement (
  nodeID: NodeID, 
  slotIndex: Uint64, 
  pledges: SCPStatement.Pledges
) {
  def encode(stream: XdrDataOutputStream): Unit = {
    nodeID.encode(stream)
    slotIndex.encode(stream)
    pledges.encode(stream)
  }
}

object SCPStatement {
  def decode(stream: XdrDataInputStream): SCPStatement = SCPStatement(
    NodeID.decode(stream),
    Uint64.decode(stream),
    Pledges.decode(stream)
  )

  sealed trait Pledges {
    def encode(stream: XdrDataOutputStream): Unit
  }

  object Pledges {
    def decode(stream: XdrDataInputStream): Pledges = SCPStatementType.decode(stream) match {
      case SCPStatementType.SCP_ST_PREPARE => SCP_ST_PREPARE(Prepare.decode(stream))
      case SCPStatementType.SCP_ST_CONFIRM => SCP_ST_CONFIRM(Confirm.decode(stream))
      case SCPStatementType.SCP_ST_EXTERNALIZE => SCP_ST_EXTERNALIZE(Externalize.decode(stream))
      case SCPStatementType.SCP_ST_NOMINATE => SCP_ST_NOMINATE(SCPNomination.decode(stream))
      case d => throw new IllegalArgumentException(s"SCPStatementType value $d is invalid")
    }

    case class SCP_ST_PREPARE(x: Prepare) extends Pledges {
      def encode(stream: XdrDataOutputStream): Unit = {
        SCPStatementType.SCP_ST_PREPARE.encode(stream)
        x.encode(stream)
      }
    }
    case class SCP_ST_CONFIRM(x: Confirm) extends Pledges {
      def encode(stream: XdrDataOutputStream): Unit = {
        SCPStatementType.SCP_ST_CONFIRM.encode(stream)
        x.encode(stream)
      }
    }
    case class SCP_ST_EXTERNALIZE(x: Externalize) extends Pledges {
      def encode(stream: XdrDataOutputStream): Unit = {
        SCPStatementType.SCP_ST_EXTERNALIZE.encode(stream)
        x.encode(stream)
      }
    }
    case class SCP_ST_NOMINATE(x: SCPNomination) extends Pledges {
      def encode(stream: XdrDataOutputStream): Unit = {
        SCPStatementType.SCP_ST_NOMINATE.encode(stream)
        x.encode(stream)
      }
    }

    case class Prepare (
      quorumSetHash: Hash, 
      ballot: SCPBallot, 
      prepared: Option[SCPBallot], 
      preparedPrime: Option[SCPBallot], 
      nC: Uint32, 
      nH: Uint32
    ) {
      def encode(stream: XdrDataOutputStream): Unit = {
        quorumSetHash.encode(stream)
        ballot.encode(stream)
        prepared match {
          case Some(x) => 
            stream.writeInt(1)
            x.encode(stream)
          case None => stream.writeInt(0)
        }
        preparedPrime match {
          case Some(x) => 
            stream.writeInt(1)
            x.encode(stream)
          case None => stream.writeInt(0)
        }
        nC.encode(stream)
        nH.encode(stream)
      }
    }

    object Prepare {
      def decode(stream: XdrDataInputStream): Prepare = Prepare(
        Hash.decode(stream),
        SCPBallot.decode(stream),
        if (stream.readInt == 0) None else Some(SCPBallot.decode(stream)),
        if (stream.readInt == 0) None else Some(SCPBallot.decode(stream)),
        Uint32.decode(stream),
        Uint32.decode(stream)
      )
    }
    case class Confirm (
      ballot: SCPBallot, 
      nPrepared: Uint32, 
      nCommit: Uint32, 
      nH: Uint32, 
      quorumSetHash: Hash
    ) {
      def encode(stream: XdrDataOutputStream): Unit = {
        ballot.encode(stream)
        nPrepared.encode(stream)
        nCommit.encode(stream)
        nH.encode(stream)
        quorumSetHash.encode(stream)
      }
    }

    object Confirm {
      def decode(stream: XdrDataInputStream): Confirm = Confirm(
        SCPBallot.decode(stream),
        Uint32.decode(stream),
        Uint32.decode(stream),
        Uint32.decode(stream),
        Hash.decode(stream)
      )
    }
    case class Externalize (
      commit: SCPBallot, 
      nH: Uint32, 
      commitQuorumSetHash: Hash
    ) {
      def encode(stream: XdrDataOutputStream): Unit = {
        commit.encode(stream)
        nH.encode(stream)
        commitQuorumSetHash.encode(stream)
      }
    }

    object Externalize {
      def decode(stream: XdrDataInputStream): Externalize = Externalize(
        SCPBallot.decode(stream),
        Uint32.decode(stream),
        Hash.decode(stream)
      )
    }
  }
}
