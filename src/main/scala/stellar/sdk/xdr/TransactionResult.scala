// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package stellar.sdk.xdr

import stellar.sdk.xdr._

// === xdr source ============================================================

//  struct TransactionResult
//  {
//      int64 feeCharged; // actual fee charged for the transaction
//  
//      union switch (TransactionResultCode code)
//      {
//      case txSUCCESS:
//      case txFAILED:
//          OperationResult results<>;
//      default:
//          void;
//      }
//      result;
//  
//      // reserved for future use
//      union switch (int v)
//      {
//      case 0:
//          void;
//      }
//      ext;
//  };

//  ===========================================================================

case class TransactionResult (
  feeCharged: Int64, 
  result: TransactionResult.Result, 
  ext: TransactionResult.Ext
) {
  def encode(stream: XdrDataOutputStream): Unit = {
    feeCharged.encode(stream)
    result.encode(stream)
    ext.encode(stream)
  }
}

object TransactionResult {
  def decode(stream: XdrDataInputStream): TransactionResult = TransactionResult(
    Int64.decode(stream),
    Result.decode(stream),
    Ext.decode(stream)
  )

  sealed trait Result {
    def encode(stream: XdrDataOutputStream): Unit
  }

  object Result {
    def decode(stream: XdrDataInputStream): Result = TransactionResultCode.decode(stream) match {
      case TransactionResultCode.TxSUCCESS => TxSUCCESS((0 until stream.readInt).map(_ => OperationResult.decode(stream)).toArray)
      case TransactionResultCode.TxFAILED => TxFAILED((0 until stream.readInt).map(_ => OperationResult.decode(stream)).toArray)
      case d => Default(d)
    }

    case class TxSUCCESS(x: Array[OperationResult]) extends Result {
      def encode(stream: XdrDataOutputStream): Unit = {
        TransactionResultCode.TxSUCCESS.encode(stream)
        stream.writeInt(x.length)
        x.foreach { _.encode(stream) }
      }
    }
    case class TxFAILED(x: Array[OperationResult]) extends Result {
      def encode(stream: XdrDataOutputStream): Unit = {
        TransactionResultCode.TxFAILED.encode(stream)
        stream.writeInt(x.length)
        x.foreach { _.encode(stream) }
      }
    }
    case class Default(d: TransactionResultCode) extends Result {
      def encode(stream: XdrDataOutputStream): Unit = {
        d.encode(stream)
      }
    }
  }
  sealed trait Ext {
    def encode(stream: XdrDataOutputStream): Unit
  }

  object Ext {
    def decode(stream: XdrDataInputStream): Ext = stream.readInt match {
      case 0 => R_0
      case d => throw new IllegalArgumentException(s"Int value $d is invalid")
    }

    case object R_0 extends Ext {
      def encode(stream: XdrDataOutputStream): Unit = {
        stream.writeInt(0)
      }
    }
  }
}
